$date
	Fri Sep 06 19:20:53 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module Processor $end
$var wire 8 ! ALU_out [7:0] $end
$var wire 1 " aux_carry_flag $end
$var wire 1 # clk $end
$var wire 8 $ instruction [7:0] $end
$var wire 4 % irq [3:0] $end
$var wire 1 & reset $end
$var wire 8 ' vector_address [7:0] $end
$var wire 1 ( set_interrupt $end
$var wire 1 ) reg_write_enable $end
$var wire 2 * reg_write_addr [1:0] $end
$var wire 2 + reg_read_addr2 [1:0] $end
$var wire 2 , reg_read_addr1 [1:0] $end
$var wire 8 - reg_data2 [7:0] $end
$var wire 8 . reg_data1 [7:0] $end
$var wire 8 / psw_out [7:0] $end
$var wire 1 0 overflow_out $end
$var wire 1 1 mem_write $end
$var wire 8 2 mem_read_data [7:0] $end
$var wire 1 3 mem_read $end
$var wire 1 4 interrupt_ack $end
$var wire 1 5 clear_interrupt $end
$var wire 1 6 carry_out $end
$var wire 8 7 alu_result [7:0] $end
$var wire 4 8 alu_opcode [3:0] $end
$upscope $end
$scope module ProcessorTestbench $end
$var wire 8 9 read_data [7:0] $end
$var wire 1 : mem_write $end
$var wire 1 ; mem_read $end
$var reg 1 < clk $end
$var reg 8 = instruction [7:0] $end
$var reg 1 > reset $end
$var reg 8 ? write_data [7:0] $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 ?
1>
b0 =
0<
0;
0:
b0 9
bx 8
bx 7
x6
x5
x4
x3
bx 2
x1
x0
bx /
bx .
bx -
bx ,
bx +
bx *
x)
x(
bx '
z&
bz %
bz $
z#
z"
bx !
$end
#5
1<
#10
0<
0>
#15
bx 9
1;
1<
#20
0<
b10101010 ?
b10010001 =
#25
b0 9
1:
0;
1<
#30
0<
#35
0:
1<
#40
0<
b10000001 =
#45
bx 9
1;
1<
#50
0<
#55
1;
1<
#60
0<
#65
b0 9
0;
1<
#70
0<
#75
bx 9
1;
1<
#80
0<
